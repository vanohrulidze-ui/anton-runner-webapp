<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Anton Runner ‚Äì Alona Beach</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- –°–∫—Ä–∏–ø—Ç Telegram WebApp -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #87CEEB; /* –Ω–µ–±–æ */
            overflow: hidden;
            touch-action: none; /* —á—Ç–æ–±—ã –∂–µ—Å—Ç—ã —Å–≤–∞–π–ø–∞ —Ä–∞–±–æ—Ç–∞–ª–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ */
        }
        #gameCanvas {
            display: block;
            background: linear-gradient(#87CEEB 40%, #00BFFF 40%, #00BFFF 55%, #FFF5EE 55%, #FFF5EE 100%);
            /* –Ω–µ–±–æ -> –º–æ—Ä–µ -> –ø–ª—è–∂ */
        }
        #overlayText {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 16px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-align: center;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="overlayText">Anton is ready!</div>

<script>
    const tg = window.Telegram?.WebApp;
    if (tg) {
        tg.expand();
        tg.enableClosingConfirmation();
    }

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ====== –ò–≥—Ä–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã ======
    const GROUND_Y_RATIO = 0.75; // —É—Ä–æ–≤–µ–Ω—å –∑–µ–º–ª–∏
    const HERO_WIDTH = 40;
    const HERO_HEIGHT = 70;
    const GRAVITY = 0.7;
    const JUMP_VELOCITY = -14;
    const GAME_SPEED = 6;
    const OBSTACLE_WIDTH = 40;
    const OBSTACLE_HEIGHT = 40;
    const BONUS_SIZE = 30;
    const MAX_LIVES = 3;
    const TOTAL_OBSTACLES_TO_WIN = 15;
    const OBSTACLE_TO_BONUS_RATIO = 4; // 4 –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è:1 –±–æ–Ω—É—Å

    // ====== –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ======
    let groundY = canvas.height * GROUND_Y_RATIO;

    let hero = {
        x: canvas.width * 0.1,
        y: groundY - HERO_HEIGHT,
        width: HERO_WIDTH,
        height: HERO_HEIGHT,
        vy: 0,
        onGround: true,
        crouching: false,
        lives: MAX_LIVES,
        score: 0,
        obstaclesPassed: 0,
        finished: false,
        alive: true
    };

    let obstacles = [];
    let bonuses = [];
    let frames = 0;
    let lastTypeWasBonus = false;
    let gameOver = false;
    let gameStarted = false;
    let touchStartY = null;

    const overlayEl = document.getElementById('overlayText');

    // ====== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ======

    function rand(min, max) {
        return Math.random() * (max - min) + min;
    }

    function spawnObstacleOrBonus() {
        const baseX = canvas.width + 20;
        const r = Math.random();

        // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –≤ 4 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ, —á–µ–º –±–æ–Ω—É—Å–æ–≤
        if (r < 1 / (OBSTACLE_TO_BONUS_RATIO + 1)) {
            // –±–æ–Ω—É—Å
            let bonus = {
                x: baseX,
                y: groundY - HERO_HEIGHT - BONUS_SIZE - rand(10, 40),
                size: BONUS_SIZE,
                type: Math.random() < 0.5 ? 'rum' : 'beer'
            };
            bonuses.push(bonus);
            lastTypeWasBonus = true;
        } else {
            // –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
            let obstacle = {
                x: baseX,
                y: groundY - OBSTACLE_HEIGHT,
                width: OBSTACLE_WIDTH,
                height: OBSTACLE_HEIGHT,
                type: Math.random() < 0.5 ? 'snake' : 'monkey'
            };
            obstacles.push(obstacle);
            lastTypeWasBonus = false;
        }
    }

    function resetGameState() {
        groundY = canvas.height * GROUND_Y_RATIO;
        hero.y = groundY - HERO_HEIGHT;
        hero.vy = 0;
        hero.onGround = true;
        hero.crouching = false;
        hero.lives = MAX_LIVES;
        hero.score = 0;
        hero.obstaclesPassed = 0;
        hero.finished = false;
        hero.alive = true;

        obstacles = [];
        bonuses = [];
        frames = 0;
        lastTypeWasBonus = false;
        gameOver = false;
        gameStarted = true;
        overlayEl.textContent = "Anton is ready!";
        setTimeout(() => { overlayEl.style.display = 'none'; }, 800);
    }

    function startGame() {
        resetGameState();
        if (tg) {
            tg.MainButton.setText("–í—ã—Ö–æ–¥ –∏–∑ –∏–≥—Ä—ã").show().onClick(() => {
                // –ø—Ä–æ—Å—Ç–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º –∏–≥—Ä—É –ø–æ –∫–Ω–æ–ø–∫–µ
                tg.close();
            });
        }
    }

    function endGame(finished) {
        gameOver = true;
        hero.finished = finished;

        if (finished) {
            overlayEl.style.display = 'block';
            overlayEl.textContent = "Oh yeah!";
        } else {
            overlayEl.style.display = 'block';
            overlayEl.textContent = "Game over";
        }

        // –ì–æ—Ç–æ–≤–∏–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –±–æ—Ç–∞
        const payload = {
            score: hero.score,
            finished: finished,
            obstacles_passed: hero.obstaclesPassed
        };

        if (tg) {
            try {
                tg.sendData(JSON.stringify(payload));
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö –≤ Telegram:", e);
            }
            setTimeout(() => tg.close(), 1200);
        }
    }

    function rectsIntersect(a, b) {
        return !(
            a.x + a.width < b.x ||
            a.x > b.x + (b.width || b.size) ||
            a.y + a.height < b.y ||
            a.y > b.y + (b.height || b.size)
        );
    }

    // ====== –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è ======

    function jump() {
        if (!hero.alive || gameOver) return;
        if (hero.onGround) {
            hero.vy = JUMP_VELOCITY;
            hero.onGround = false;
        }
    }

    function crouchStart() {
        if (!hero.alive || gameOver) return;
        if (hero.onGround) {
            hero.crouching = true;
            hero.height = HERO_HEIGHT * 0.5;
            hero.y = groundY - hero.height;
        }
    }

    function crouchEnd() {
        if (!hero.alive || gameOver) return;
        if (hero.crouching) {
            hero.crouching = false;
            hero.height = HERO_HEIGHT;
            hero.y = groundY - hero.height;
        }
    }

    // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–∞
    window.addEventListener('keydown', (e) => {
        if (!gameStarted) {
            startGame();
        }
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            jump();
        } else if (e.code === 'ArrowDown') {
            crouchStart();
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowDown') {
            crouchEnd();
        }
    });

    // –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –∂–µ—Å—Ç—ã (—Å–≤–∞–π–ø –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)
    canvas.addEventListener('touchstart', (e) => {
        if (!gameStarted) {
            startGame();
        }
        if (e.touches.length === 1) {
            touchStartY = e.touches[0].clientY;
        }
    });

    canvas.addEventListener('touchend', (e) => {
        if (touchStartY === null) return;
        const touchEndY = e.changedTouches[0].clientY;
        const dy = touchEndY - touchStartY;

        if (dy < -30) {
            // —Å–≤–∞–π–ø –≤–≤–µ—Ä—Ö
            jump();
        } else if (dy > 30) {
            // —Å–≤–∞–π–ø –≤–Ω–∏–∑
            crouchStart();
            setTimeout(crouchEnd, 300);
        }

        touchStartY = null;
    });

    // ====== –û—Ç—Ä–∏—Å–æ–≤–∫–∞ ======

    function drawBackground() {
        const h = canvas.height;

        // –ù–µ–±–æ —É–∂–µ —Å–¥–µ–ª–∞–Ω–æ –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º —Ñ–æ–Ω–∞. –î–æ–±–∞–≤–∏–º –ø–∞–ª—å–º—ã –∏ –Ω–∞–¥–ø–∏—Å—å Alona Beach.

        // –ü–ª—è–∂–Ω–∞—è –ª–∏–Ω–∏—è
        ctx.fillStyle = "#FFF5EE";
        ctx.fillRect(0, groundY, canvas.width, h - groundY);

        // –ú–æ—Ä–µ
        ctx.fillStyle = "#00BFFF";
        ctx.fillRect(0, groundY - 40, canvas.width, 40);

        // –ù–∞–¥–ø–∏—Å—å "Alona Beach"
        ctx.fillStyle = "white";
        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Alona Beach", canvas.width / 2, groundY - 60);

        // –ü–∞—Ä–∞ —É—Å–ª–æ–≤–Ω—ã—Ö –ø–∞–ª—å–º
        function drawPalm(x) {
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(x, groundY - 120, 10, 120);
            ctx.fillStyle = "#228B22";
            ctx.beginPath();
            ctx.ellipse(x - 15, groundY - 130, 25, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 20, groundY - 135, 30, 14, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        drawPalm(canvas.width * 0.2);
        drawPalm(canvas.width * 0.8);
    }

    function drawHero() {
        // –¢–µ–ª–æ –ê–Ω—Ç–æ–Ω–∞
        ctx.fillStyle = "#F5DEB3"; // –∫–æ–∂–∞
        // –Ω–æ–≥–∏
        ctx.fillRect(hero.x + 5, hero.y + hero.height - 20, 10, 20);
        ctx.fillRect(hero.x + 25, hero.y + hero.height - 20, 10, 20);

        // —à–ª—ë–ø–∫–∏
        ctx.fillStyle = "#000000";
        ctx.fillRect(hero.x + 3, hero.y + hero.height, 14, 4);
        ctx.fillRect(hero.x + 23, hero.y + hero.height, 14, 4);

        // —à–æ—Ä—Ç—ã
        ctx.fillStyle = "#1E90FF";
        ctx.fillRect(hero.x, hero.y + hero.height - 40, hero.width, 25);

        // –º–∞–π–∫–∞
        ctx.fillStyle = "#000000";
        ctx.fillRect(hero.x, hero.y + 15, hero.width, hero.height - 55);

        // –≥–æ–ª–æ–≤–∞
        ctx.fillStyle = "#F5DEB3";
        ctx.beginPath();
        ctx.arc(hero.x + hero.width / 2, hero.y + 10, 12, 0, Math.PI * 2);
        ctx.fill();

        // –±–æ—Ä–æ–¥–∞
        ctx.fillStyle = "#654321";
        ctx.beginPath();
        ctx.arc(hero.x + hero.width / 2, hero.y + 16, 10, Math.PI * 0.1, Math.PI * 0.9);
        ctx.fill();

        // —Ç–∞—Ç—É –Ω–∞ –ø–ª–µ—á–µ
        ctx.fillStyle = "#333333";
        ctx.fillRect(hero.x + 2, hero.y + 30, 8, 8);
    }

    function drawObstacle(o) {
        ctx.fillStyle = o.type === 'snake' ? "#006400" : "#8B4513";
        ctx.fillRect(o.x, o.y, o.width, o.height);
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(o.type === 'snake' ? "üêç" : "üêí", o.x + o.width / 2, o.y + o.height / 2 + 4);
    }

    function drawBonus(b) {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(b.x + b.size / 2, b.y + b.size / 2, b.size / 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#8B4513";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(b.type === 'rum' ? "üçπ" : "üç∫", b.x + b.size / 2, b.y + b.size / 2 + 4);
    }

    function drawHUD() {
        // –ñ–∏–∑–Ω–∏ (—Å–µ—Ä–¥–µ—á–∫–∏)
        const heartSize = 18;
        ctx.font = `${heartSize}px Arial`;
        ctx.textAlign = "left";
        ctx.fillStyle = "#FF0000";
        let hearts = "";
        for (let i = 0; i < hero.lives; i++) {
            hearts += "‚ù§ ";
        }
        ctx.fillText(hearts, 10, 30);

        // –û—á–∫–∏
        ctx.fillStyle = "#000000";
        ctx.font = "18px Arial";
        ctx.textAlign = "right";
        ctx.fillText(`Score: ${hero.score}`, canvas.width - 10, 30);

        // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        ctx.textAlign = "right";
        ctx.fillText(
            `Obstacles: ${hero.obstaclesPassed}/${TOTAL_OBSTACLES_TO_WIN}`,
            canvas.width - 10,
            55
        );
    }

    // ====== –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ======

    function update() {
        if (!gameStarted || gameOver) return;

        frames++;

        // –°–ø–∞–≤–Ω –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π/–±–æ–Ω—É—Å–æ–≤
        if (frames % 60 === 0) { // –ø—Ä–∏–º–µ—Ä–Ω–æ —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
            spawnObstacleOrBonus();
        }

        // –§–∏–∑–∏–∫–∞ –≥–µ—Ä–æ—è
        if (!hero.onGround) {
            hero.vy += GRAVITY;
            hero.y += hero.vy;

            if (hero.y + hero.height >= groundY) {
                hero.y = groundY - hero.height;
                hero.vy = 0;
                hero.onGround = true;
            }
        }

        // –î–≤–∏–∂–µ–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –∏ –±–æ–Ω—É—Å–æ–≤
        obstacles.forEach(o => o.x -= GAME_SPEED);
        bonuses.forEach(b => b.x -= GAME_SPEED);

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞ –∑–∞ —ç–∫—Ä–∞–Ω
        obstacles = obstacles.filter(o => {
            if (o.x + o.width < 0) {
                // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–π–¥–µ–Ω–æ
                hero.obstaclesPassed += 1;
                hero.score += 10;

                if (hero.obstaclesPassed >= TOTAL_OBSTACLES_TO_WIN && !gameOver) {
                    // –ü–æ–±–µ–¥–∞, –Ω–æ –¥–∞–¥–∏–º —á—É—Ç—å –≤—Ä–µ–º–µ–Ω–∏ –¥–æ–±–µ–∂–∞—Ç—å –¥–æ "–¥–µ–≤—É—à–µ–∫"
                    endGame(true);
                }

                return false;
            }
            return true;
        });

        bonuses = bonuses.filter(b => b.x + b.size > 0);

        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
        const heroRect = {
            x: hero.x,
            y: hero.y,
            width: hero.width,
            height: hero.height
        };

        obstacles.forEach((o) => {
            if (!gameOver && rectsIntersect(heroRect, o)) {
                // –ü–æ—Ç–µ—Ä—è –∂–∏–∑–Ω–∏
                hero.lives -= 1;
                // –û—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º –Ω–µ–º–Ω–æ–≥–æ –Ω–∞–∑–∞–¥
                hero.x = canvas.width * 0.1;
                // —É–±–∏—Ä–∞–µ–º –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ
                o.x = -9999;

                if (hero.lives <= 0) {
                    hero.alive = false;
                    endGame(false);
                }
            }
        });

        bonuses.forEach((b) => {
            if (!gameOver && rectsIntersect(heroRect, b)) {
                // +1 –∂–∏–∑–Ω—å (–Ω–æ –Ω–µ –±–æ–ª—å—à–µ MAX_LIVES)
                hero.lives = Math.min(MAX_LIVES, hero.lives + 1);
                hero.score += 5;
                b.x = -9999;
            }
        });

        // –ï—Å–ª–∏ –≥–µ—Ä–æ–π ¬´—É–º–µ—Ä¬ª –∏ –µ—â—ë –Ω–µ –≤—ã–∑—ã–≤–∞–ª–∏ endGame ‚Äì –≤—ã–∑—ã–≤–∞–µ–º
        if (!hero.alive && !gameOver) {
            endGame(false);
        }
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();

        if (gameStarted) {
            // –ê–Ω—Ç–æ–Ω
            drawHero();

            // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
            obstacles.forEach(drawObstacle);

            // –ë–æ–Ω—É—Å—ã
            bonuses.forEach(drawBonus);

            // –ï—Å–ª–∏ –ø–æ–±–µ–¥–∞ ‚Äì —Ä–∏—Å—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—Ü–µ–Ω—É
            if (hero.finished) {
                // –¢—Ä–∏ –¥–µ–≤—É—à–∫–∏ –∑–∞ —Ñ–∏–Ω–∏—à–Ω–æ–π —á–µ—Ä—Ç–æ–π
                const baseX = canvas.width * 0.7;

                function drawGirl(x) {
                    const baseY = groundY - 80;
                    ctx.fillStyle = "#8B4513"; // –∫–æ–∂–∞ –ø–æ—Ç–µ–º–Ω–µ–µ
                    // –Ω–æ–≥–∏
                    ctx.fillRect(x + 5, baseY + 30, 10, 30);
                    ctx.fillRect(x + 25, baseY + 30, 10, 30);
                    // —Ç–µ–ª–æ
                    ctx.fillRect(x, baseY, 40, 40);
                    // –≥–æ–ª–æ–≤–∞
                    ctx.beginPath();
                    ctx.arc(x + 20, baseY - 10, 12, 0, Math.PI * 2);
                    ctx.fill();
                    // –∫—É–ø–∞–ª—å–Ω–∏–∫
                    ctx.fillStyle = "#FF69B4";
                    ctx.fillRect(x, baseY + 10, 40, 8);
                    ctx.fillRect(x, baseY + 30, 40, 12);
                }

                drawGirl(baseX - 60);
                drawGirl(baseX);
                drawGirl(baseX + 60);

                // –ê–Ω—Ç–æ–Ω –≤ —Ü–µ–Ω—Ç—Ä–µ
                ctx.save();
                ctx.translate(baseX, groundY - HERO_HEIGHT);
                // –ø–æ–¥–Ω—è—Ç—ã–µ —Ä—É–∫–∏ ‚Äì –ø—Ä–æ—Å—Ç–æ –Ω–∞–¥–ø–∏—Å—å
                ctx.restore();
            }

            drawHUD();
        } else {
            // –î–æ —Å—Ç–∞—Ä—Ç–∞ –ø—Ä–æ—Å—Ç–æ —Ñ–æ–Ω –∏ –Ω–∞–¥–ø–∏—Å—å
            ctx.fillStyle = "#000000";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
                "–ù–∞–∂–º–∏ –ø–æ —ç–∫—Ä–∞–Ω—É –∏–ª–∏ –Ω–∞–∂–º–∏ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å",
                canvas.width / 2,
                canvas.height / 2
            );
        }

        requestAnimationFrame(render);
    }

    function gameLoop() {
        update();
        requestAnimationFrame(gameLoop);
    }

    // –°—Ç–∞—Ä—Ç—É–µ–º
    render();
    gameLoop();

</script>
</body>
</html>
