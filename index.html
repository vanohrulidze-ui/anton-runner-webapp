<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Anton Beach Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      max-width: 100%;
      max-height: 100%;
      background: #4ec0ff;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .overlay-inner {
      pointer-events: auto;
      background: rgba(255,255,255,0.96);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      max-width: 90%;
      text-align: center;
    }
    .overlay-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .overlay-text {
      font-size: 14px;
      margin-bottom: 12px;
    }
    .overlay-btn {
      display: inline-block;
      padding: 10px 18px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      background: linear-gradient(135deg, #ff8a00, #ff3d3d);
      color: #fff;
      cursor: pointer;
    }
    .overlay-btn:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }
    .speech {
      position: absolute;
      left: 50%;
      bottom: 65%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: #fff;
      border-radius: 16px;
      border: 2px solid #222;
      font-weight: 600;
      font-size: 16px;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    }
    .speech::after {
      content: "";
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 10px 10px 0 10px;
      border-style: solid;
      border-color: #fff transparent transparent transparent;
      filter: drop-shadow(0 -2px 0 #222);
    }
    .hud-hint {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      pointer-events: none;
    }
  </style>
  <!-- —Å–∫—Ä–∏–ø—Ç –¢–µ–ª–µ–≥—Ä–∞–º–∞: –ø—Ä–∏ –ª–æ–∫–∞–ª—å–Ω–æ–º –æ—Ç–∫—Ä—ã—Ç–∏–∏ –ø—Ä–æ—Å—Ç–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="960" height="540"></canvas>

    <div id="start-overlay" class="overlay">
      <div class="overlay-inner">
        <div class="overlay-title">Anton Beach Runner</div>
        <div class="overlay-text">
          –ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç¬ª, —á—Ç–æ–±—ã –ê–Ω—Ç–æ–Ω –ø–æ–±–µ–∂–∞–ª –ø–æ –ø–ª—è–∂—É Alona Beach!<br/>
          –¢–∞–ø –ø–æ –≤–µ—Ä—Ö–Ω–µ–π –ø–æ–ª–æ–≤–∏–Ω–µ —ç–∫—Ä–∞–Ω–∞ ‚Äî –ø—Ä—ã–∂–æ–∫, –ø–æ –Ω–∏–∂–Ω–µ–π ‚Äî –ø—Ä–∏—Å–µ—Å—Ç—å.
        </div>
        <button class="overlay-btn" id="start-btn">–°—Ç–∞—Ä—Ç</button>
      </div>
    </div>

    <div id="end-overlay" class="overlay" style="display:none;">
      <div class="overlay-inner">
        <div class="overlay-title" id="end-title"></div>
        <div class="overlay-text" id="end-text"></div>
        <button class="overlay-btn" id="restart-btn">–°—ã–≥—Ä–∞—Ç—å –µ—â—ë</button>
      </div>
    </div>

    <div id="speech-bubble" class="speech" style="display:none;"></div>

    <div class="hud-hint">
      –í–µ—Ä—Ö —ç–∫—Ä–∞–Ω–∞ ‚Äî –ø—Ä—ã–∂–æ–∫, –Ω–∏–∑ ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è. –ù–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ: ‚Üë / Space ‚Äî –ø—Ä—ã–∂–æ–∫, ‚Üì ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è.
    </div>
  </div>

  <script>
    // –ü–æ–ª–∏—Ñ–∏–ª –¥–ª—è roundRect (–Ω–∞ —Å–ª—É—á–∞–π —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤ / Safari)
    (function() {
      const proto = CanvasRenderingContext2D && CanvasRenderingContext2D.prototype;
      if (!proto || proto.roundRect) return;
      proto.roundRect = function(x, y, width, height, radius) {
        let r = radius || 0;
        if (typeof r === 'number') {
          r = { tl: r, tr: r, br: r, bl: r };
        } else {
          const def = { tl: 0, tr: 0, br: 0, bl: 0 };
          for (let k in def) {
            r[k] = r[k] || def[k];
          }
        }
        this.moveTo(x + r.tl, y);
        this.lineTo(x + width - r.tr, y);
        this.quadraticCurveTo(x + width, y, x + width, y + r.tr);
        this.lineTo(x + width, y + height - r.br);
        this.quadraticCurveTo(x + width, y + height, x + width - r.br, y + height);
        this.lineTo(x + r.bl, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - r.bl);
        this.lineTo(x, y + r.tl);
        this.quadraticCurveTo(x, y, x + r.tl, y);
        this.closePath();
        return this;
      };
    })();

    // --- –±–∞–∑–æ–≤–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ canvas ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // --- —Ä–µ—Å—É—Ä—Å—ã (–∫–∞—Ä—Ç–∏–Ω–∫–∏) ---
    function loadImage(src) {
      const img = new Image();
      img.src = src;
      return img;
    }

    const images = {
      bg: loadImage('img/beach_bg.png'),
      antonRun: loadImage('img/anton_run.png'),
      antonWin: loadImage('img/anton_win.png'), // –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
      girls: loadImage('img/girls_final.png')
    };

    // --- —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ---
    let gameState = 'ready'; // ready | running | finishing | finished
    let lastTime = 0;

    const game = {
      speed: 6,
      maxLives: 3,
      lives: 3,
      score: 0,
      obstaclesPassed: 0,
      totalObstaclesToWin: 15,
      bgOffset: 0,
      bgParallax: 0.4,
      spawnTimer: 0,
      spawnInterval: 1.2,
      bonusesCounter: 0
    };

    const player = {
      x: WIDTH * 0.2,
      y: 0,
      width: 110,
      height: 190,
      vy: 0,
      gravity: 1.1,
      jumpStrength: 20,
      isOnGround: true,
      isSliding: false,
      slideTimer: 0,
      slideDuration: 0.45,
      runBobPhase: 0,
      hitTimer: 0,
      invincibleTime: 1.2
    };

    const groundY = HEIGHT * 0.78;
    player.y = groundY - player.height;

    const obstacles = [];
    const bonuses = [];
    const flyingHearts = [];

    function spawnObstacle() {
      const types = ['snake', 'monkey'];
      const type = types[Math.random() < 0.5 ? 0 : 1];

      obstacles.push({
        type,
        x: WIDTH + 40,
        y: groundY - 40,
        width: 60,
        height: 40,
        passed: false
      });

      game.bonusesCounter++;
      if (game.bonusesCounter >= 4) {
        game.bonusesCounter = 0;
        const bonusTypes = ['rum', 'beer'];
        const bType = bonusTypes[Math.random() < 0.5 ? 0 : 1];

        bonuses.push({
          type: bType,
          x: WIDTH + 40,
          y: groundY - player.height - 60,
          width: 34,
          height: 54
        });
      }
    }

    function rectsOverlap(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function clamp(v, min, max) {
      return v < min ? min : (v > max ? max : v);
    }

    function jump() {
      if (!player.isOnGround || gameState !== 'running') return;
      player.vy = -player.jumpStrength;
      player.isOnGround = false;
    }

    function slide() {
      if (gameState !== 'running') return;
      if (player.isSliding || !player.isOnGround) return;
      player.isSliding = true;
      player.slideTimer = player.slideDuration;
    }

    window.addEventListener('keydown', e => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        if (gameState === 'ready') {
          startGame();
        } else {
          jump();
        }
      } else if (e.code === 'ArrowDown') {
        e.preventDefault();
        slide();
      }
    });

    function pointerHandler(ev) {
      if (gameState === 'ready') {
        startGame();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const y = (ev.clientY || (ev.touches && ev.touches[0].clientY)) - rect.top;
      const relative = y / rect.height;
      if (relative <= 0.5) {
        jump();
      } else {
        slide();
      }
    }

    canvas.addEventListener('pointerdown', pointerHandler, { passive: false });
    canvas.addEventListener('touchstart', pointerHandler, { passive: false });

    const startOverlay = document.getElementById('start-overlay');
    const endOverlay   = document.getElementById('end-overlay');
    const startBtn     = document.getElementById('start-btn');
    const restartBtn   = document.getElementById('restart-btn');
    const endTitle     = document.getElementById('end-title');
    const endText      = document.getElementById('end-text');
    const speechBubble = document.getElementById('speech-bubble');

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', () => {
      resetGame();
      startGame();
    });

    function showSpeech(text, duration = 1.5) {
      speechBubble.textContent = text;
      speechBubble.style.display = 'block';
      setTimeout(() => {
        if (speechBubble.textContent === text) {
          speechBubble.style.display = 'none';
        }
      }, duration * 1000);
    }

    function startGame() {
      if (gameState === 'running') return;
      startOverlay.style.display = 'none';
      endOverlay.style.display = 'none';
      gameState = 'running';
      showSpeech('Anton is ready!', 1.5);
    }

    function resetGame() {
      gameState = 'ready';
      game.speed = 6;
      game.lives = game.maxLives;
      game.score = 0;
      game.obstaclesPassed = 0;
      game.bgOffset = 0;
      game.spawnTimer = 0;
      game.bonusesCounter = 0;
      obstacles.length = 0;
      bonuses.length = 0;
      flyingHearts.length = 0;

      player.x = WIDTH * 0.2;
      player.y = groundY - player.height;
      player.vy = 0;
      player.isOnGround = true;
      player.isSliding = false;
      player.slideTimer = 0;
      player.runBobPhase = 0;
      player.hitTimer = 0;
    }

    function finishGame(won) {
      gameState = 'finished';
      endOverlay.style.display = 'flex';
      if (won) {
        endTitle.textContent = '–ü–æ–±–µ–¥–∞!';
        endText.textContent = `–¢—ã –ø—Ä–æ—à—ë–ª –≤—Å–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è –∏ –¥–æ–±–µ–∂–∞–ª –¥–æ –¥–µ–≤—É—à–µ–∫ üéâ –û—á–∫–∏: ${game.score}`;
      } else {
        endTitle.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞';
        endText.textContent = `–ê–Ω—Ç–æ–Ω —É—Å—Ç–∞–ª üòÖ –¢–≤–æ–∏ –æ—á–∫–∏: ${game.score}`;
      }

      try {
        if (window.Telegram && Telegram.WebApp) {
          Telegram.WebApp.sendData(JSON.stringify({
            type: 'game_result',
            score: game.score,
            won
          }));
        }
      } catch(e) {
        console.log('Telegram WebApp.sendData error', e);
      }
    }

    function drawBackground(dt) {
      const bg = images.bg;
      const speed = game.speed * game.bgParallax;

      if (gameState === 'running' || gameState === 'finishing') {
        game.bgOffset -= speed;
        if (game.bgOffset <= -bg.width) {
          game.bgOffset += bg.width;
        }
      }

      const patternWidth = bg.width;
      let x = game.bgOffset;

      while (x < WIDTH) {
        ctx.drawImage(bg, x, 0, patternWidth, HEIGHT);
        x += patternWidth;
      }

      ctx.font = '32px system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = 'rgba(0,0,0,0.65)';
      ctx.lineWidth = 4;
      ctx.textAlign = 'center';
      const labelX = WIDTH * 0.5;
      const labelY = HEIGHT * 0.35;
      ctx.strokeText('Alona Beach', labelX, labelY);
      ctx.fillText('Alona Beach', labelX, labelY);
      ctx.textAlign = 'left';
    }

    function drawHearts() {
      const margin = 16;
      const size = 26;
      for (let i = 0; i < game.maxLives; i++) {
        const x = margin + i * (size + 6);
        const y = margin;
        if (i < game.lives) {
          drawHeartShape(x, y, size, size, '#ff4b6a', '#ff9aa8');
        } else {
          drawHeartShape(x, y, size, size, 'rgba(255,255,255,0.25)', 'rgba(255,255,255,0.1)', true);
        }
      }
    }

    function drawScore() {
      ctx.font = '20px system-ui';
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillText(`Score: ${game.score}`, WIDTH - 150, 30);
      ctx.fillText(`Lives: ${game.lives}`, WIDTH - 150, 55);
    }

    function drawPlayer(dt) {
      let drawX = player.x;
      let drawY = player.y;

      if (gameState === 'running' || gameState === 'finishing') {
        player.runBobPhase += dt * (player.isOnGround ? 8 : 4);
        const bob = Math.sin(player.runBobPhase) * 4;
        drawY += bob;
      }

      let h = player.height;
      let w = player.width;
      if (player.isSliding) {
        h *= 0.65;
        w *= 1.1;
        drawY = groundY - h + 8;
      }

      if (player.hitTimer > 0) {
        const alphaPulse = Math.sin(player.hitTimer * 25);
        if (alphaPulse > 0) {
          ctx.save();
          ctx.globalAlpha = 0.5;
          drawAntonSprite(drawX, drawY, w, h);
          ctx.restore();
        }
      } else {
        drawAntonSprite(drawX, drawY, w, h);
      }
    }

    function drawAntonSprite(x, y, w, h, winPose = false) {
      const img = (winPose && images.antonWin && images.antonWin.complete && images.antonWin.naturalWidth)
        ? images.antonWin
        : images.antonRun;
      ctx.drawImage(img, x - w * 0.5, y, w, h);
    }

    function drawObstacles() {
      obstacles.forEach(o => {
        const baseY = o.y;
        if (o.type === 'snake') {
          drawSnake(o.x, baseY, o.width, o.height);
        } else {
          drawMonkey(o.x, baseY - 10, o.width + 10, o.height + 10);
        }
      });
    }

    function drawBonuses() {
      bonuses.forEach(b => {
        drawBottle(b.x, b.y, b.width, b.height, b.type === 'beer');
      });
    }

    function drawGirlsAndFinish(dt) {
      const girlsWidth = 260;
      const girlsHeight = 260;
      const girlsX = WIDTH * 0.72;
      const girlsY = groundY - girlsHeight + 10;

      if (gameState === 'finishing') {
        const t = performance.now() / 300;
        const bounce = Math.sin(t) * 8;
        ctx.drawImage(images.girls, girlsX, girlsY + bounce, girlsWidth, girlsHeight);

        if (player.x < girlsX - 60) {
          player.x += 220 * dt;
        } else {
          player.x = girlsX - 40;
          drawAntonSprite(player.x, player.y, player.width, player.height, true);
          showSpeech('Oh yeah!', 2.0);
          finishGame(true);
        }
      } else if (gameState === 'finished') {
        ctx.drawImage(images.girls, girlsX, girlsY, girlsWidth, girlsHeight);
      }
    }

    function drawHeartShape(x, y, w, h, colorFill, colorHighlight, outlineOnly = false) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      const r = w / 4;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy + r);
      ctx.bezierCurveTo(cx + r * 2, cy - r, cx + r, cy - r * 2, cx, cy - r);
      ctx.bezierCurveTo(cx - r, cy - r * 2, cx - r * 2, cy - r, cx, cy + r);
      ctx.closePath();

      if (!outlineOnly) {
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, colorHighlight);
        grad.addColorStop(1, colorFill);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      } else {
        ctx.strokeStyle = colorFill;
        ctx.lineWidth = 1.6;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawSnake(x, y, w, h) {
      ctx.save();
      ctx.translate(x, y);
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, '#4caf50');
      grad.addColorStop(1, '#1b5e20');
      ctx.fillStyle = grad;
      ctx.strokeStyle = '#0a3310';
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(0, h * 0.7);
      ctx.quadraticCurveTo(w * 0.25, h * 0.2, w * 0.5, h * 0.7);
      ctx.quadraticCurveTo(w * 0.75, h * 1.1, w, h * 0.7);
      ctx.quadraticCurveTo(w * 0.8, h * 0.3, w * 0.5, h * 0.35);
      ctx.quadraticCurveTo(w * 0.2, h * 0.4, 0, h * 0.7);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(w * 0.15, h * 0.35, 3, 0, Math.PI * 2);
      ctx.arc(w * 0.28, h * 0.33, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(w * 0.15, h * 0.35, 1.5, 0, Math.PI * 2);
      ctx.arc(w * 0.28, h * 0.33, 1.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawMonkey(x, y, w, h) {
      ctx.save();
      ctx.translate(x, y);
      const bodyW = w * 0.5;
      const bodyH = h * 0.6;
      const headR = h * 0.23;

      const gradBody = ctx.createLinearGradient(0, 0, 0, bodyH);
      gradBody.addColorStop(0, '#8d6e63');
      gradBody.addColorStop(1, '#5d4037');
      ctx.fillStyle = gradBody;
      ctx.beginPath();
      ctx.roundRect(w * 0.25, h * 0.4, bodyW, bodyH, 12);
      ctx.fill();

      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.35, headR, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#ffcc80';
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.38, headR * 0.8, headR * 0.6, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(w * 0.47, h * 0.34, 2.5, 0, Math.PI * 2);
      ctx.arc(w * 0.53, h * 0.34, 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#5d4037';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.4, 6, 0, Math.PI);
      ctx.stroke();

      ctx.restore();
    }

    function drawBottle(x, y, w, h, isBeer) {
      ctx.save();
      ctx.translate(x, y);

      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h + 6, w * 0.6, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      const grad = ctx.createLinearGradient(0, 0, 0, h);
      if (isBeer) {
        grad.addColorStop(0, '#ffe082');
        grad.addColorStop(1, '#ffb300');
      } else {
        grad.addColorStop(0, '#ffab91');
        grad.addColorStop(1, '#d84315');
      }
      ctx.fillStyle = grad;
      ctx.strokeStyle = '#4e342e';
      ctx.lineWidth = 2;

      const neckW = w * 0.35;
      const neckH = h * 0.28;
      const bodyW = w * 0.7;
      const bodyH = h * 0.65;

      ctx.beginPath();
      ctx.roundRect((w - neckW)/2, 0, neckW, neckH, 4);
      ctx.roundRect((w - bodyW)/2, neckH, bodyW, bodyH, 8);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.beginPath();
      ctx.roundRect((w - bodyW*0.7)/2, neckH + bodyH*0.25, bodyW*0.7, bodyH*0.4, 6);
      ctx.fill();

      ctx.restore();
    }

    function spawnFlyingHeart(fromX, fromY) {
      const margin = 16;
      const size = 26;
      const heartsX = margin + (game.lives-1) * (size + 6) + size/2;
      const heartsY = margin + size/2;

      flyingHearts.push({
        x: fromX,
        y: fromY,
        startX: fromX,
        startY: fromY,
        targetX: heartsX,
        targetY: heartsY,
        t: 0,
        duration: 0.5
      });
    }

    function updateFlyingHearts(dt) {
      for (let i = flyingHearts.length - 1; i >= 0; i--) {
        const h = flyingHearts[i];
        h.t += dt;
        const k = clamp(h.t / h.duration, 0, 1);
        const lift = -60 * Math.sin(k * Math.PI);
        h.x = h.startX + (h.targetX - h.startX) * k;
        h.y = h.startY + (h.targetY - h.startY) * k + lift;
        if (k >= 1) {
          flyingHearts.splice(i, 1);
        }
      }
    }

    function drawFlyingHearts() {
      flyingHearts.forEach(h => {
        drawHeartShape(h.x - 13, h.y - 13, 26, 26, '#ff4b6a', '#ff9aa8');
      });
    }

    function update(dt) {
      if (gameState === 'running') {
        game.speed = 6 + game.obstaclesPassed * 0.2;

        player.vy += player.gravity;
        player.y += player.vy;
        if (player.y >= groundY - player.height) {
          player.y = groundY - player.height;
          player.vy = 0;
          player.isOnGround = true;
        }

        if (player.isSliding) {
          player.slideTimer -= dt;
          if (player.slideTimer <= 0) {
            player.isSliding = false;
          }
        }

        if (player.hitTimer > 0) {
          player.hitTimer -= dt;
          if (player.hitTimer < 0) player.hitTimer = 0;
        }

        game.spawnTimer -= dt;
        if (game.spawnTimer <= 0) {
          spawnObstacle();
          game.spawnTimer = game.spawnInterval;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const o = obstacles[i];
          o.x -= game.speed;
          if (!o.passed && o.x + o.width < player.x) {
            o.passed = true;
            game.obstaclesPassed++;
            game.score += 10;

            if (game.obstaclesPassed >= game.totalObstaclesToWin && gameState === 'running') {
              gameState = 'finishing';
            }
          }
          if (o.x + o.width < -40) {
            obstacles.splice(i, 1);
          }
        }

        for (let i = bonuses.length - 1; i >= 0; i--) {
          const b = bonuses[i];
          b.x -= game.speed;
          if (b.x + b.width < -40) {
            bonuses.splice(i, 1);
            continue;
          }

          const playerBox = getPlayerHitbox();
          if (rectsOverlap(playerBox, b)) {
            bonuses.splice(i, 1);
            if (game.lives < game.maxLives) {
              game.lives++;
              spawnFlyingHeart(b.x + b.width/2, b.y + b.height/2);
            }
          }
        }

        const playerBox = getPlayerHitbox();
        obstacles.forEach(o => {
          if (rectsOverlap(playerBox, o) && player.hitTimer <= 0) {
            game.lives--;
            player.hitTimer = player.invincibleTime;
            if (game.lives <= 0) {
              finishGame(false);
            }
          }
        });

        updateFlyingHearts(dt);
      } else if (gameState === 'finishing') {
        updateFlyingHearts(dt);
      }
    }

    function getPlayerHitbox() {
      let w = player.width * 0.55;
      let h = player.height * 0.85;
      let x = player.x - w * 0.5;
      let y = player.y + (player.height - h);

      if (player.isSliding) {
        h *= 0.7;
        w *= 1.1;
        y = groundY - h + 4;
      }

      return { x, y, width: w, height: h };
    }

    function render(dt) {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      drawBackground(dt);
      drawHearts();
      drawScore();
      drawObstacles();
      drawBonuses();
      drawPlayer(dt);
      drawFlyingHearts();

      if (gameState === 'finishing' || gameState === 'finished') {
        drawGirlsAndFinish(dt);
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      render(dt);

      requestAnimationFrame(loop);
    }

    resetGame();
    showSpeech('Anton is ready!');

    requestAnimationFrame(loop);
  </script>
</body>
</html>
