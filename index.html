<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Anton Beach Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      touch-action: none;
    }
    canvas {
      max-width: 100%;
      max-height: 100%;
      background: #4ec0ff;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .overlay-inner {
      pointer-events: auto;
      background: rgba(255,255,255,0.96);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      max-width: 90%;
      text-align: center;
    }
    .overlay-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .overlay-text {
      font-size: 14px;
      margin-bottom: 12px;
    }
    .overlay-btn {
      display: inline-block;
      padding: 10px 18px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      background: linear-gradient(135deg, #ff8a00, #ff3d3d);
      color: #fff;
      cursor: pointer;
    }
    .overlay-btn:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }

    .speech {
      position: absolute;
      left: 50%;
      bottom: 65%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: #fff;
      border-radius: 16px;
      border: 2px solid #222;
      font-weight: 600;
      font-size: 16px;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      display: none;
    }
    .speech::after {
      content: "";
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 10px 10px 0 10px;
      border-style: solid;
      border-color: #fff transparent transparent transparent;
    }

    .hud-hint {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="960" height="540"></canvas>

    <div id="start-overlay" class="overlay">
      <div class="overlay-inner">
        <div class="overlay-title">Anton Beach Runner</div>
        <div class="overlay-text">
          –ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç¬ª, —á—Ç–æ–±—ã –ê–Ω—Ç–æ–Ω –ø–æ–±–µ–∂–∞–ª –ø–æ –ø–ª—è–∂—É Alona Beach!<br/>
          –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞ ‚Äî –ø—Ä—ã–∂–æ–∫, –Ω–∏–∂–Ω—è—è ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è.
        </div>
        <button class="overlay-btn" id="start-btn">–°—Ç–∞—Ä—Ç</button>
      </div>
    </div>

    <div id="end-overlay" class="overlay" style="display:none;">
      <div class="overlay-inner">
        <div class="overlay-title" id="end-title"></div>
        <div class="overlay-text" id="end-text"></div>
        <button class="overlay-btn" id="restart-btn">–°—ã–≥—Ä–∞—Ç—å –µ—â—ë</button>
      </div>
    </div>

    <div id="speech-bubble" class="speech"></div>

    <div class="hud-hint">
      –í–µ—Ä—Ö —ç–∫—Ä–∞–Ω–∞ ‚Äî –ø—Ä—ã–∂–æ–∫, –Ω–∏–∑ ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è. –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞: ‚Üë / Space ‚Äî –ø—Ä—ã–∂–æ–∫, ‚Üì ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è.
    </div>
  </div>

  <script>
    console.log("Game script loaded");

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // --- –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ---
    function loadImage(src) {
      const img = new Image();
      img.src = src;
      return img;
    }

    const images = {
      bg: loadImage('img/beach_bg.png'),
      girls: loadImage('img/girls_final.png'),
      antonJump: loadImage('img/anton_jump.png'),
      antonWin: loadImage('img/anton_win.png'),
      snake: loadImage('img/snake.png'),
      monkey: loadImage('img/monkey.png'),
      beer: loadImage('img/beer.png'),
      rum: loadImage('img/rum.png')
    };

    const RUN_FRAME_COUNT = 7;
    const runFrames = [];
    for (let i = 1; i <= RUN_FRAME_COUNT; i++) {
      runFrames.push(loadImage(`img/run-sheet/run${i}.png`));
    }

    // --- —Å–æ—Å—Ç–æ—è–Ω–∏—è ---
    let gameState = 'ready'; // ready | running | finishing | final_scene | finished
    let lastTime = 0;

    const groundY = HEIGHT * 0.78;

    const GIRLS_WIDTH = 260;
    const GIRLS_HEIGHT = 260;
    const GIRLS_X = WIDTH * 0.72;
    const GIRLS_Y = groundY - GIRLS_HEIGHT + 10;

    const game = {
      speed: 5,                 // —Å–Ω–∏–∂–µ–Ω–∞ –±–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
      maxLives: 3,
      lives: 3,
      score: 0,
      obstaclesPassed: 0,
      totalObstaclesToWin: 20,  // –ø–æ–±–µ–¥–∞ –ø–æ—Å–ª–µ 20 –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
      bgOffset: 0,
      bgParallax: 0.4,
      spawnTimer: 0,
      spawnInterval: 2.4,       // —É–≤–µ–ª–∏—á–µ–Ω–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏
      bonusesCounter: 0
    };

    let finalSceneTimer = 0; // —Ç–∞–π–º–µ—Ä —Ñ–∏–Ω–∞–ª—å–Ω–æ–π —Å—Ü–µ–Ω—ã (5 —Å–µ–∫—É–Ω–¥)

    const player = {
      x: WIDTH * 0.2,
      y: 0,
      width: 110,
      height: 190,
      vy: 0,
      gravity: 1.1,
      jumpStrength: 20,
      isOnGround: true,
      isSliding: false,
      slideTimer: 0,
      slideDuration: 0.45,
      runBobPhase: 0,
      runAnimTime: 0,
      hitTimer: 0,
      invincibleTime: 1.2
    };
    player.y = groundY - player.height;

    const obstacles = [];
    const bonuses = [];
    const flyingHearts = [];

    // --- DOM —ç–ª–µ–º–µ–Ω—Ç—ã ---
    const startOverlay = document.getElementById('start-overlay');
    const endOverlay = document.getElementById('end-overlay');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const endTitle = document.getElementById('end-title');
    const endText = document.getElementById('end-text');
    const speechBubble = document.getElementById('speech-bubble');

    // --- —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
    function jump() {
      if (!player.isOnGround || gameState !== 'running') return;
      player.vy = -player.jumpStrength;
      player.isOnGround = false;
    }

    function slide() {
      if (gameState !== 'running') return;
      if (player.isSliding || !player.isOnGround) return;
      player.isSliding = true;
      player.slideTimer = player.slideDuration;
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        if (gameState === 'ready') {
          startGame();
        } else {
          jump();
        }
      } else if (e.code === 'ArrowDown') {
        e.preventDefault();
        slide();
      }
    });

    function pointerHandler(ev) {
      if (gameState === 'ready') {
        startGame();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const clientY = ev.clientY || (ev.touches && ev.touches[0].clientY);
      if (!clientY) return;
      const y = clientY - rect.top;
      const rel = y / rect.height;
      if (rel <= 0.5) jump(); else slide();
    }

    canvas.addEventListener('pointerdown', pointerHandler, { passive: false });
    canvas.addEventListener('touchstart', pointerHandler, { passive: false });

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', () => {
      resetGame();
      startGame();
    });

    function showSpeech(text, duration = 1.5) {
      speechBubble.textContent = text;
      speechBubble.style.display = 'block';
      setTimeout(() => {
        if (speechBubble.textContent === text) {
          speechBubble.style.display = 'none';
        }
      }, duration * 1000);
    }

    function startGame() {
      if (gameState === 'running') return;
      startOverlay.style.display = 'none';
      endOverlay.style.display = 'none';
      gameState = 'running';
      showSpeech('Anton is ready!', 1.5);
    }

    function resetGame() {
      gameState = 'ready';
      game.speed = 5;
      game.lives = game.maxLives;
      game.score = 0;
      game.obstaclesPassed = 0;
      game.bgOffset = 0;
      game.spawnTimer = 0;
      game.bonusesCounter = 0;
      finalSceneTimer = 0;

      obstacles.length = 0;
      bonuses.length = 0;
      flyingHearts.length = 0;

      player.x = WIDTH * 0.2;
      player.y = groundY - player.height;
      player.vy = 0;
      player.isOnGround = true;
      player.isSliding = false;
      player.slideTimer = 0;
      player.runBobPhase = 0;
      player.runAnimTime = 0;
      player.hitTimer = 0;
    }

    function finishGame(won) {
      gameState = 'finished';
      endOverlay.style.display = 'flex';
      if (won) {
        endTitle.textContent = '–ü–æ–±–µ–¥–∞!';
        endText.textContent = `–¢—ã –¥–æ—à—ë–ª –¥–æ –¥–µ–≤—É—à–µ–∫ üéâ –û—á–∫–∏: ${game.score}`;
      } else {
        endTitle.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞';
        endText.textContent = `–ê–Ω—Ç–æ–Ω —É—Å—Ç–∞–ª üòÖ –¢–≤–æ–∏ –æ—á–∫–∏: ${game.score}`;
      }

      // —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram (–≤ WebApp) ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω–æ, –µ—Å–ª–∏ —Ç–∞–º –∑–∞–ø—É—Å–∫
      try {
        if (window.Telegram && window.Telegram.WebApp) {
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: 'game_result',
            score: game.score,
            won
          }));
        }
      } catch (e) {
        console.log('Telegram sendData error', e);
      }
    }

    // --- –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π / –±–æ–Ω—É—Å–æ–≤ ---
    function spawnObstacle() {
      const types = ['snake', 'monkey'];
      const type = types[Math.random() < 0.5 ? 0 : 1];

      const oHeight = 80;
      const oWidth = 80;

      obstacles.push({
        type,
        x: WIDTH + 40,
        y: groundY - oHeight,
        width: oWidth,
        height: oHeight,
        passed: false
      });

      game.bonusesCounter++;
      if (game.bonusesCounter >= 4) {
        game.bonusesCounter = 0;
        const bType = Math.random() < 0.5 ? 'rum' : 'beer';
        const bHeight = 70;
        const bWidth = 40;
        bonuses.push({
          type: bType,
          x: WIDTH + 40,
          y: groundY - player.height - 60,
          width: bWidth,
          height: bHeight
        });
      }
    }

    function rectsOverlap(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function clamp(v, min, max) {
      return v < min ? min : (v > max ? max : v);
    }

    function getPlayerHitbox() {
      let w = player.width * 0.55;
      let h = player.height * 0.85;
      let x = player.x - w * 0.5;
      let y = player.y + (player.height - h);

      if (player.isSliding) {
        h *= 0.7;
        w *= 1.1;
        y = groundY - h + 4;
      }

      return { x, y, width: w, height: h };
    }

    function spawnFlyingHeart(fromX, fromY) {
      const margin = 16;
      const size = 26;
      const heartsX = margin + (game.lives - 1) * (size + 6) + size / 2;
      const heartsY = margin + size / 2;

      flyingHearts.push({
        x: fromX,
        y: fromY,
        startX: fromX,
        startY: fromY,
        targetX: heartsX,
        targetY: heartsY,
        t: 0,
        duration: 0.5
      });
    }

    function updateFlyingHearts(dt) {
      for (let i = flyingHearts.length - 1; i >= 0; i--) {
        const h = flyingHearts[i];
        h.t += dt;
        const k = clamp(h.t / h.duration, 0, 1);
        const lift = -60 * Math.sin(k * Math.PI);
        h.x = h.startX + (h.targetX - h.startX) * k;
        h.y = h.startY + (h.targetY - h.startY) * k + lift;
        if (k >= 1) {
          flyingHearts.splice(i, 1);
        }
      }
    }

    // --- –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ ---
    function drawBackground(dt) {
      const bg = images.bg;
      const speed = game.speed * game.bgParallax;

      if (gameState === 'running' || gameState === 'finishing') {
        game.bgOffset -= speed;
        if (bg.width > 0 && game.bgOffset <= -bg.width) {
          game.bgOffset += bg.width;
        }
      }

      if (bg.complete && bg.naturalWidth) {
        const patternWidth = bg.width;
        let x = game.bgOffset;

        while (x < WIDTH) {
          ctx.drawImage(bg, x, 0, patternWidth, HEIGHT);
          x += patternWidth;
        }
      } else {
        // –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ —Ñ–æ–Ω –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è
        ctx.fillStyle = '#4ec0ff';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#ffe0b2';
        ctx.fillRect(0, groundY, WIDTH, HEIGHT - groundY);
      }

      // –Ω–∞–¥–ø–∏—Å—å Alona Beach
      ctx.font = '32px system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = 'rgba(0,0,0,0.65)';
      ctx.lineWidth = 4;
      ctx.textAlign = 'center';
      const labelX = WIDTH * 0.5;
      const labelY = HEIGHT * 0.35;
      ctx.strokeText('Alona Beach', labelX, labelY);
      ctx.fillText('Alona Beach', labelX, labelY);
      ctx.textAlign = 'left';
    }

    function drawHearts() {
      const margin = 16;
      const size = 26;

      for (let i = 0; i < game.maxLives; i++) {
        const x = margin + i * (size + 6);
        const y = margin;
        if (i < game.lives) {
          drawHeartShape(x, y, size, size, '#ff4b6a', '#ff9aa8', false);
        } else {
          drawHeartShape(x, y, size, size, 'rgba(255,255,255,0.25)', 'rgba(255,255,255,0.1)', true);
        }
      }
    }

    function drawScore() {
      ctx.font = '20px system-ui';
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillText(`Score: ${game.score}`, WIDTH - 150, 30);
      ctx.fillText(`Lives: ${game.lives}`, WIDTH - 150, 55);
    }

    function drawHeartShape(x, y, w, h, colorFill, colorHighlight, outlineOnly) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      const r = w / 4;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy + r);
      ctx.bezierCurveTo(cx + r * 2, cy - r, cx + r, cy - r * 2, cx, cy - r);
      ctx.bezierCurveTo(cx - r, cy - r * 2, cx - r * 2, cy - r, cx, cy + r);
      ctx.closePath();

      if (!outlineOnly) {
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, colorHighlight);
        grad.addColorStop(1, colorFill);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      } else {
        ctx.strokeStyle = colorFill;
        ctx.lineWidth = 1.6;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawPlayer(dt) {
      let drawX = player.x;
      let drawY = player.y;

      if (gameState === 'running' || gameState === 'finishing') {
        player.runBobPhase += dt * (player.isOnGround ? 8 : 4);
        const bob = Math.sin(player.runBobPhase) * 4;
        drawY += bob;
      }

      let w = player.width;
      let h = player.height;
      if (player.isSliding) {
        h *= 0.65;
        w *= 1.1;
        drawY = groundY - h + 8;
      }

      ctx.save();

      if (player.hitTimer > 0) {
        const pulse = Math.sin(player.hitTimer * 25);
        if (pulse > 0) {
          ctx.globalAlpha = 0.5;
        }
      }

      let imgToDraw = null;

      if (!player.isOnGround) {
        // –≤–æ –≤—Ä–µ–º—è –ø—Ä—ã–∂–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º anton_jump
        if (images.antonJump.complete && images.antonJump.naturalWidth) {
          imgToDraw = images.antonJump;
        }
      } else {
        // –∞–Ω–∏–º–∞—Ü–∏—è –±–µ–≥–∞ –ø–æ —Å–ø—Ä–∞–π—Ç–∞–º
        const anyLoaded = runFrames.some(f => f.complete && f.naturalWidth);
        if (anyLoaded) {
          const frameIndex = Math.floor(player.runAnimTime * 12) % runFrames.length;
          const frame = runFrames[frameIndex];
          if (frame && frame.complete && frame.naturalWidth) {
            imgToDraw = frame;
          }
        }
      }

      if (imgToDraw) {
        ctx.drawImage(imgToDraw, drawX - w * 0.5, drawY, w, h);
      } else {
        // –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äî –ø—Ä–æ—Å—Ç–æ —Å–∏–ª—É—ç—Ç
        ctx.fillStyle = '#222';
        ctx.fillRect(drawX - w * 0.5, drawY, w, h);
      }

      ctx.restore();
    }

    function drawObstacles() {
      obstacles.forEach(o => {
        let img = null;
        if (o.type === 'snake') {
          img = images.snake;
        } else {
          img = images.monkey;
        }
        if (img && img.complete && img.naturalWidth) {
          ctx.drawImage(img, o.x, o.y, o.width, o.height);
        } else {
          // –∑–∞–ø–∞—Å–Ω–æ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
          ctx.fillStyle = '#4caf50';
          ctx.fillRect(o.x, o.y, o.width, o.height);
        }
      });
    }

    function drawBonuses() {
      bonuses.forEach(b => {
        let img = null;
        if (b.type === 'beer') {
          img = images.beer;
        } else {
          img = images.rum;
        }
        if (img && img.complete && img.naturalWidth) {
          ctx.drawImage(img, b.x, b.y, b.width, b.height);
        } else {
          ctx.fillStyle = '#ffb300';
          ctx.fillRect(b.x, b.y, b.width, b.height);
        }
      });
    }

    function drawGirls(dt) {
      if (!images.girls.complete || !images.girls.naturalWidth) return;

      let y = GIRLS_Y;
      // –≤–æ –≤—Ä–µ–º—è —Ñ–∏–Ω–∏—à–Ω–æ–≥–æ –∑–∞–±–µ–≥–∞ ‚Äî –ª—ë–≥–∫–∏–π "–ø–æ–¥–ø—Ä—ã–≥"
      if (gameState === 'finishing') {
        const t = performance.now() / 300;
        y += Math.sin(t) * 8;
      }
      ctx.drawImage(images.girls, GIRLS_X, y, GIRLS_WIDTH, GIRLS_HEIGHT);
    }

    function drawFinalScene() {
      const img = images.antonWin;
      if (img && img.complete && img.naturalWidth) {
        // –ø–µ—Ä–µ–Ω–æ—Å–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å–ø—Ä–∞–π—Ç –≤ —Ü–µ–Ω—Ç—Ä —ç–∫—Ä–∞–Ω–∞
        const maxW = WIDTH * 0.6;
        const maxH = HEIGHT * 0.6;
        const scale = Math.min(maxW / img.width, maxH / img.height, 1);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const x = (WIDTH - drawW) / 2;
        const y = (HEIGHT - drawH) / 2;
        ctx.drawImage(img, x, y, drawW, drawH);
      } else {
        // –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äî –±–æ–ª—å—à–æ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫-–ø–ª–∞—à–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
        const w = WIDTH * 0.4;
        const h = HEIGHT * 0.4;
        const x = (WIDTH - w) / 2;
        const y = (HEIGHT - h) / 2;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = '#fff';
        ctx.font = '28px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Anton Win!', WIDTH / 2, HEIGHT / 2);
        ctx.textAlign = 'left';
      }
    }

    function drawFlyingHearts() {
      flyingHearts.forEach(h => {
        drawHeartShape(h.x - 13, h.y - 13, 26, 26, '#ff4b6a', '#ff9aa8', false);
      });
    }

    // --- –∞–ø–¥–µ–π—Ç –∏ —Ä–µ–Ω–¥–µ—Ä ---
    function update(dt) {
      if (gameState === 'running') {
        // —á—É—Ç—å —Å–Ω–∏–∂–µ–Ω–Ω–∞—è –∏ –º—è–≥—á–µ —Ä–∞—Å—Ç—É—â–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        game.speed = 5 + game.obstaclesPassed * 0.15;

        player.runAnimTime += dt;

        player.vy += player.gravity;
        player.y += player.vy;
        if (player.y >= groundY - player.height) {
          player.y = groundY - player.height;
          player.vy = 0;
          player.isOnGround = true;
        }

        if (player.isSliding) {
          player.slideTimer -= dt;
          if (player.slideTimer <= 0) {
            player.isSliding = false;
          }
        }

        if (player.hitTimer > 0) {
          player.hitTimer -= dt;
          if (player.hitTimer < 0) player.hitTimer = 0;
        }

        game.spawnTimer -= dt;
        if (game.spawnTimer <= 0) {
          spawnObstacle();
          game.spawnTimer = game.spawnInterval;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const o = obstacles[i];
          o.x -= game.speed;
          if (!o.passed && o.x + o.width < player.x) {
            o.passed = true;
            game.obstaclesPassed++;
            game.score += 10;

            if (game.obstaclesPassed >= game.totalObstaclesToWin && gameState === 'running') {
              // –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π ‚Äî –Ω–∞—á–∏–Ω–∞–µ–º —Ñ–∏–Ω–∏—à–Ω—ã–π –∑–∞–±–µ–≥ –∫ –¥–µ–≤—É—à–∫–∞–º
              gameState = 'finishing';
              // —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∏–≥—Ä–æ–∫–∞ –Ω–∞ –∑–µ–º–ª–µ
              player.isOnGround = true;
              player.vy = 0;
              player.y = groundY - player.height;
            }
          }
          if (o.x + o.width < -40) {
            obstacles.splice(i, 1);
          }
        }

        for (let i = bonuses.length - 1; i >= 0; i--) {
          const b = bonuses[i];
          b.x -= game.speed;
          if (b.x + b.width < -40) {
            bonuses.splice(i, 1);
            continue;
          }

          const pb = getPlayerHitbox();
          if (rectsOverlap(pb, b)) {
            bonuses.splice(i, 1);
            if (game.lives < game.maxLives) {
              game.lives++;
              spawnFlyingHeart(b.x + b.width/2, b.y + b.height/2);
            }
          }
        }

        const pb = getPlayerHitbox();
        obstacles.forEach(o => {
          if (rectsOverlap(pb, o) && player.hitTimer <= 0) {
            game.lives--;
            player.hitTimer = player.invincibleTime;
            if (game.lives <= 0) {
              finishGame(false);
            }
          }
        });

        updateFlyingHearts(dt);
      } else if (gameState === 'finishing') {
        // —Ñ–∏–Ω–∏—à–Ω—ã–π –∑–∞–±–µ–≥ –∫ –¥–µ–≤—É—à–∫–∞–º
        player.runAnimTime += dt;
        const targetX = GIRLS_X - 60;
        const dir = targetX - player.x;
        const move = Math.sign(dir) * game.speed * 1.6 * dt;
        if (Math.abs(dir) <= Math.abs(move)) {
          player.x = targetX;

          // –∑–∞–ø—É—Å–∫–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—Ü–µ–Ω—É
          gameState = 'final_scene';
          finalSceneTimer = 5.0; // 5 —Å–µ–∫—É–Ω–¥
          showSpeech('Oh yeah!', 2.0);
        } else {
          player.x += move;
        }

        // —Ñ–æ–Ω—ã –∏ —Å–µ—Ä–¥—Ü–∞ –≤—Å—ë –µ—â—ë –º–æ–≥—É—Ç –∂–∏—Ç—å
        updateFlyingHearts(dt);
      } else if (gameState === 'final_scene') {
        // —Ç–æ–ª—å–∫–æ —Ç–∞–π–º–µ—Ä —Ñ–∏–Ω–∞–ª—å–Ω–æ–π —Å—Ü–µ–Ω—ã
        finalSceneTimer -= dt;
        if (finalSceneTimer <= 0 && gameState === 'final_scene') {
          finishGame(true);
        }
      }
    }

    function render(dt) {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawBackground(dt);

      if (gameState !== 'final_scene') {
        // –î–µ–≤—É—à–∫–∏ —Å—Ç–æ—è—Ç —Å–ø—Ä–∞–≤–∞ —Å —Å–∞–º–æ–≥–æ –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã
        drawGirls(dt);

        drawHearts();
        drawScore();
        drawObstacles();
        drawBonuses();
        drawPlayer(dt);
        drawFlyingHearts();
      } else {
        // —Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Å—Ü–µ–Ω–∞ ‚Äî —Ç–æ–ª—å–∫–æ —Ñ–æ–Ω –∏ –ø–æ–±–µ–¥–Ω—ã–π –ê–Ω—Ç–æ–Ω
        drawFinalScene();
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      render(dt);

      requestAnimationFrame(loop);
    }

    resetGame();
    showSpeech('Anton is ready!', 1.5);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
