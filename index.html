<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Anton Beach Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      touch-action: none;
    }
    canvas {
      max-width: 100%;
      max-height: 100%;
      background: #4ec0ff;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.4);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .overlay-inner {
      pointer-events: auto;
      background: rgba(255,255,255,0.96);
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      max-width: 90%;
      text-align: center;
    }
    .overlay-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .overlay-text {
      font-size: 14px;
      margin-bottom: 12px;
    }
    .overlay-btn {
      display: inline-block;
      padding: 10px 18px;
      border-radius: 999px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      background: linear-gradient(135deg, #ff8a00, #ff3d3d);
      color: #fff;
      cursor: pointer;
    }
    .overlay-btn:active {
      transform: translateY(1px);
      filter: brightness(0.95);
    }

    .speech {
      position: absolute;
      left: 50%;
      bottom: 65%;
      transform: translateX(-50%);
      padding: 8px 14px;
      background: #fff;
      border-radius: 16px;
      border: 2px solid #222;
      font-weight: 600;
      font-size: 16px;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      display: none;
    }
    .speech::after {
      content: "";
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      border-width: 10px 10px 0 10px;
      border-style: solid;
      border-color: #fff transparent transparent transparent;
    }

    .hud-hint {
      position: absolute;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" width="960" height="540"></canvas>

    <div id="start-overlay" class="overlay">
      <div class="overlay-inner">
        <div class="overlay-title">Anton Beach Runner</div>
        <div class="overlay-text">
          –ù–∞–∂–º–∏ ¬´–°—Ç–∞—Ä—Ç¬ª, —á—Ç–æ–±—ã –ê–Ω—Ç–æ–Ω –ø–æ–±–µ–∂–∞–ª –ø–æ –ø–ª—è–∂—É Alona Beach!<br/>
          –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å —ç–∫—Ä–∞–Ω–∞ ‚Äî –ø—Ä—ã–∂–æ–∫, –Ω–∏–∂–Ω—è—è ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è.
        </div>
        <button class="overlay-btn" id="start-btn">–°—Ç–∞—Ä—Ç</button>
      </div>
    </div>

    <div id="end-overlay" class="overlay" style="display:none;">
      <div class="overlay-inner">
        <div class="overlay-title" id="end-title"></div>
        <div class="overlay-text" id="end-text"></div>
        <button class="overlay-btn" id="restart-btn">–°—ã–≥—Ä–∞—Ç—å –µ—â—ë</button>
      </div>
    </div>

    <div id="speech-bubble" class="speech"></div>

    <div class="hud-hint">
      –í–µ—Ä—Ö —ç–∫—Ä–∞–Ω–∞ ‚Äî –ø—Ä—ã–∂–æ–∫, –Ω–∏–∑ ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è. –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞: ‚Üë / Space ‚Äî –ø—Ä—ã–∂–æ–∫, ‚Üì ‚Äî –ø—Ä–∏–≥–Ω—É—Ç—å—Å—è.
    </div>
  </div>

  <script>
    console.log("Game script loaded");

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // --- –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è ---
    function loadImage(src) {
      const img = new Image();
      img.src = src;
      return img;
    }

    const images = {
      bg: loadImage('img/beach_bg.png'),
      antonJump: loadImage('img/anton_jump.png'),
      // —Å—Ç–∞—Ç–∏—á–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö —Ñ–æ–ª–±–µ–∫–æ–≤
      girlsStatic: loadImage('img/girls_final.png'),
      antonWinStatic: loadImage('img/anton_win.png')
    };

    // –≥–µ—Ä–æ–π - –±–µ–≥
    const RUN_FRAME_COUNT = 7;
    const runFrames = [];
    for (let i = 1; i <= RUN_FRAME_COUNT; i++) {
      runFrames.push(loadImage(`img/run-sheet/run${i}.png`));
    }

    // --- –°–ü–†–ê–ô–¢-–õ–ò–°–¢–´ ---
    const SNAKE_FRAME_COUNT = 6;
    const MONKEY_FRAME_COUNT = 6;
    const BEER_FRAME_COUNT  = 6;
    const RUM_FRAME_COUNT   = 6;
    const GIRLS_FRAME_COUNT = 8;
    const WIN_FRAME_COUNT   = 8;

    function loadSheetFrames(count, pathBuilder) {
      const arr = [];
      for (let i = 1; i <= count; i++) {
        arr.push(loadImage(pathBuilder(i)));
      }
      return arr;
    }

    const snakeFrames = loadSheetFrames(
      SNAKE_FRAME_COUNT,
      i => `img/snake-sheet/snake_${String(i).padStart(3,'0')}.png`
    );

    const monkeyFrames = loadSheetFrames(
      MONKEY_FRAME_COUNT,
      i => `img/monkey-sheet/monkey_${String(i).padStart(3,'0')}.png`
    );

    const beerFrames = loadSheetFrames(
      BEER_FRAME_COUNT,
      i => `img/beer-sheet/beer_${String(i).padStart(3,'0')}.png`
    );

    const rumFrames = loadSheetFrames(
      RUM_FRAME_COUNT,
      i => `img/rum-sheet/rum_${String(i).padStart(3,'0')}.png`
    );

    const girlsFrames = loadSheetFrames(
      GIRLS_FRAME_COUNT,
      i => `img/girls-final-sheet/girls_final_${String(i).padStart(3,'0')}.png`
    );

    const winFrames = loadSheetFrames(
      WIN_FRAME_COUNT,
      i => `img/win-sheet/anton_win_${String(i).padStart(3,'0')}.png`
    );

    // helper –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π –±–µ–∑ "—á—ë—Ä–Ω–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç–∞"
    function getAnimatedFrame(frames, time, fps, fallbackImg) {
      const allLoaded = frames.length &&
        frames.every(f => f.complete && f.naturalWidth);

      if (allLoaded) {
        const idx = Math.floor(time * fps) % frames.length;
        return frames[idx];
      }

      if (fallbackImg && fallbackImg.complete && fallbackImg.naturalWidth) {
        return fallbackImg;
      }

      return null;
    }

    // --- —Å–æ—Å—Ç–æ—è–Ω–∏—è ---
    let gameState = 'ready'; // ready | running | finishing | final_scene | finished
    let lastTime = 0;

    const groundY = HEIGHT * 0.78;

    const GIRLS_WIDTH = 260;
    const GIRLS_HEIGHT = 260;
    const GIRLS_X = WIDTH - GIRLS_WIDTH - Math.round(WIDTH * 0.02);
    const GIRLS_Y = groundY - GIRLS_HEIGHT + 10;

    const game = {
      speed: 8,
      maxLives: 3,
      lives: 3,
      score: 0,
      obstaclesPassed: 0,
      totalObstaclesToWin: 15,   // –ø–æ–±–µ–¥–∞ –ø–æ—Å–ª–µ 15 –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
      bgOffset: 0,
      bgParallax: 0.4,
      spawnTimer: 0,
      spawnInterval: 2.7,        // –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–µ–∂–¥—É —Å–ø–∞–≤–Ω–∞–º–∏ (—Å–µ–∫—É–Ω–¥—ã)
      bonusesCounter: 0
    };

    let finalSceneTimer = 0;

    // –≤—Ä–µ–º–µ–Ω–∞ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π —Å–ø—Ä–∞–π—Ç-–ª–∏—Å—Ç–æ–≤
    let obstacleAnimTime = 0;
    let bonusAnimTime = 0;
    let girlsAnimTime = 0;
    let finalAnimTime = 0;

    const player = {
      x: WIDTH * 0.2,
      y: 0,
      width: 120,
      height: 200,
      vy: 0,
      gravity: 1.6,
      jumpStrength: 20,
      isOnGround: true,
      isSliding: false,
      slideTimer: 0,
      slideDuration: 0.45,
      runBobPhase: 0,
      runAnimTime: 0,
      hitTimer: 0,
      invincibleTime: 1.2
    };
    player.y = groundY - player.height;

    const obstacles = [];
    const bonuses = [];
    const flyingHearts = [];

    // --- DOM —ç–ª–µ–º–µ–Ω—Ç—ã ---
    const startOverlay = document.getElementById('start-overlay');
    const endOverlay = document.getElementById('end-overlay');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const endTitle = document.getElementById('end-title');
    const endText = document.getElementById('end-text');
    const speechBubble = document.getElementById('speech-bubble');

    // --- —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
    function jump() {
      if (!player.isOnGround || gameState !== 'running') return;
      player.vy = -player.jumpStrength;
      player.isOnGround = false;
    }

    function slide() {
      if (gameState !== 'running') return;
      if (player.isSliding || !player.isOnGround) return;
      player.isSliding = true;
      player.slideTimer = player.slideDuration;
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        if (gameState === 'ready') {
          startGame();
        } else {
          jump();
        }
      } else if (e.code === 'ArrowDown') {
        e.preventDefault();
        slide();
      }
    });

    function pointerHandler(ev) {
      if (gameState === 'ready') {
        startGame();
        return;
      }
      const rect = canvas.getBoundingClientRect();
      const clientY = ev.clientY || (ev.touches && ev.touches[0].clientY);
      if (!clientY) return;
      const y = clientY - rect.top;
      const rel = y / rect.height;
      if (rel <= 0.5) jump(); else slide();
    }

    canvas.addEventListener('pointerdown', pointerHandler, { passive: false });
    canvas.addEventListener('touchstart', pointerHandler, { passive: false });

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', () => {
      resetGame();
      startGame();
    });

    function showSpeech(text, duration = 1.5) {
      speechBubble.textContent = text;
      speechBubble.style.display = 'block';
      setTimeout(() => {
        if (speechBubble.textContent === text) {
          speechBubble.style.display = 'none';
        }
      }, duration * 1000);
    }

    function startGame() {
      if (gameState === 'running') return;
      startOverlay.style.display = 'none';
      endOverlay.style.display = 'none';
      gameState = 'running';
      showSpeech('Anton is ready!', 1.5);
    }

    function resetGame() {
      gameState = 'ready';
      game.speed = 8;
      game.lives = game.maxLives;
      game.score = 0;
      game.obstaclesPassed = 0;
      game.bgOffset = 0;
      game.spawnTimer = 0;
      game.bonusesCounter = 0;
      obstacles.length = 0;
      bonuses.length = 0;
      flyingHearts.length = 0;

      player.x = WIDTH * 0.2;
      player.y = groundY - player.height;
      player.vy = 0;
      player.isOnGround = true;
      player.isSliding = false;
      player.slideTimer = 0;
      player.runBobPhase = 0;
      player.runAnimTime = 0;
      player.hitTimer = 0;

      finalSceneTimer = 0;
      finalAnimTime = 0;
      obstacleAnimTime = 0;
      bonusAnimTime = 0;
      girlsAnimTime = 0;
    }

    function finishGame(won) {
      gameState = 'finished';
      endOverlay.style.display = 'flex';
      if (won) {
        endTitle.textContent = '–ü–æ–±–µ–¥–∞!';
        endText.textContent = `–¢—ã –¥–æ—à—ë–ª –¥–æ –¥–µ–≤—É—à–µ–∫ üéâ –û—á–∫–∏: ${game.score}`;
      } else {
        endTitle.textContent = '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞';
        endText.textContent = `–ê–Ω—Ç–æ–Ω —É—Å—Ç–∞–ª üòÖ –¢–≤–æ–∏ –æ—á–∫–∏: ${game.score}`;
      }

      try {
        if (window.Telegram && window.Telegram.WebApp) {
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: 'game_result',
            score: game.score,
            won
          }));
        }
      } catch (e) {
        console.log('Telegram sendData error', e);
      }
    }

    // --- –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π / –±–æ–Ω—É—Å–æ–≤ ---
    function spawnObstacle() {
      const types = ['snake', 'monkey'];
      const type = types[Math.random() < 0.5 ? 0 : 1];

      const oHeight = 80;
      const oWidth = 80;

      obstacles.push({
        type,
        x: WIDTH + 40 + 200 + Math.random() * 150,
        y: groundY - oHeight,
        width: oWidth,
        height: oHeight,
        passed: false
      });

      game.bonusesCounter++;
      if (game.bonusesCounter >= 3) {   // –±–æ–Ω—É—Å—ã —á–∞—â–µ, —á–µ–º —Ä–∞–Ω—å—à–µ
        game.bonusesCounter = 0;
        const bType = Math.random() < 0.5 ? 'beer' : 'rum';
        const bHeight = 70;
        const bWidth = 90;
        bonuses.push({
          type: bType,
          x: WIDTH + 40,
          y: groundY - player.height - 60,
          width: bWidth,
          height: bHeight
        });
      }
    }

    function rectsOverlap(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function clamp(v, min, max) {
      return v < min ? min : (v > max ? max : v);
    }

    function getPlayerHitbox() {
      let w = player.width * 0.45;
      let h = player.height * 0.6;
      let x = player.x - w * 0.5;
      let y = player.y + (player.height - h) - 4;

      if (player.isSliding) {
        h *= 0.8;
        y = groundY - h + 4;
      }

      return { x, y, width: w, height: h };
    }

    function spawnFlyingHeart(fromX, fromY) {
      const margin = 16;
      const size = 26;
      const heartsX = margin + (game.lives - 1) * (size + 6) + size / 2;
      const heartsY = margin + size / 2;

      flyingHearts.push({
        x: fromX,
        y: fromY,
        startX: fromX,
        startY: fromY,
        targetX: heartsX,
        targetY: heartsY,
        t: 0,
        duration: 0.5
      });
    }

    function updateFlyingHearts(dt) {
      for (let i = flyingHearts.length - 1; i >= 0; i--) {
        const h = flyingHearts[i];
        h.t += dt;
        const k = clamp(h.t / h.duration, 0, 1);
        const lift = -60 * Math.sin(k * Math.PI);
        h.x = h.startX + (h.targetX - h.startX) * k;
        h.y = h.startY + (h.targetY - h.startY) * k + lift;
        if (k >= 1) {
          flyingHearts.splice(i, 1);
        }
      }
    }

    // --- –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ ---
    function drawBackground(dt) {
      const bg = images.bg;
      const speed = game.speed * game.bgParallax;

      if (gameState === 'running' || gameState === 'finishing') {
        game.bgOffset -= speed;
        if (bg.width > 0 && game.bgOffset <= -bg.width) {
          game.bgOffset += bg.width;
        }
      }

      if (bg.complete && bg.naturalWidth) {
        const patternWidth = bg.width;
        let x = game.bgOffset;

        while (x < WIDTH) {
          ctx.drawImage(bg, x, 0, patternWidth, HEIGHT);
          x += patternWidth;
        }
      } else {
        ctx.fillStyle = '#4ec0ff';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#ffe0b2';
        ctx.fillRect(0, groundY, WIDTH, HEIGHT - groundY);
      }

      ctx.font = '32px system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.strokeStyle = 'rgba(0,0,0,0.65)';
      ctx.lineWidth = 4;
      ctx.textAlign = 'center';
      const labelX = WIDTH * 0.5;
      const labelY = HEIGHT * 0.35;
      ctx.strokeText('Alona Beach', labelX, labelY);
      ctx.fillText('Alona Beach', labelX, labelY);
      ctx.textAlign = 'left';
    }

    function drawHearts() {
      const margin = 16;
      const size = 26;

      for (let i = 0; i < game.maxLives; i++) {
        const x = margin + i * (size + 6);
        const y = margin;
        if (i < game.lives) {
          drawHeartShape(x, y, size, size, '#ff4b6a', '#ff9aa8', false);
        } else {
          drawHeartShape(x, y, size, size, 'rgba(255,255,255,0.25)', 'rgba(255,255,255,0.1)', true);
        }
      }
    }

    function drawScore() {
      ctx.font = '20px system-ui';
      ctx.fillStyle = 'rgba(0,0,0,0.75)';
      ctx.fillText(`Score: ${game.score}`, WIDTH - 150, 30);
      ctx.fillText(`Lives: ${game.lives}`, WIDTH - 150, 55);
    }

    function drawHeartShape(x, y, w, h, colorFill, colorHighlight, outlineOnly) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      const r = w / 4;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy + r);
      ctx.bezierCurveTo(cx + r * 2, cy - r, cx + r, cy - r * 2, cx, cy - r);
      ctx.bezierCurveTo(cx - r, cy - r * 2, cx - r * 2, cy - r, cx, cy + r);
      ctx.closePath();

      if (!outlineOnly) {
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, colorHighlight);
        grad.addColorStop(1, colorFill);
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      } else {
        ctx.strokeStyle = colorFill;
        ctx.lineWidth = 1.6;
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawPlayer(dt) {
      let drawX = player.x;
      let drawY = player.y;

      if (gameState === 'running' || gameState === 'finishing') {
        player.runBobPhase += dt * (player.isOnGround ? 8 : 4);
        const bob = Math.sin(player.runBobPhase) * 4;
        drawY += bob;
      }

      let w = player.width;
      let h = player.height;
      if (player.isSliding) {
        h *= 0.65;
        w *= 1.1;
        drawY = groundY - h + 8;
      }

      ctx.save();

      if (player.hitTimer > 0) {
        const pulse = Math.sin(player.hitTimer * 25);
        if (pulse > 0) {
          ctx.globalAlpha = 0.5;
        }
      }

      let imgToDraw = null;

      if (!player.isOnGround) {
        if (images.antonJump.complete && images.antonJump.naturalWidth) {
          imgToDraw = images.antonJump;
        }
      } else {
        const allRunFramesLoaded = runFrames.length &&
          runFrames.every(f => f.complete && f.naturalWidth);
        if (allRunFramesLoaded) {
          const frameIndex = Math.floor(player.runAnimTime * 12) % runFrames.length;
          const frame = runFrames[frameIndex];
          if (frame) {
            imgToDraw = frame;
          }
        }
      }

      if (imgToDraw) {
        ctx.drawImage(imgToDraw, drawX - w * 0.5, drawY, w, h);
      } else {
        ctx.fillStyle = '#222';
        ctx.fillRect(drawX - w * 0.5, drawY, w, h);
      }

      ctx.restore();
    }

    function drawObstacles() {
      obstacles.forEach(o => {
        let img = null;
        if (o.type === 'snake') {
          img = getAnimatedFrame(snakeFrames, obstacleAnimTime, 10, null);
        } else {
          img = getAnimatedFrame(monkeyFrames, obstacleAnimTime, 10, null);
        }

        if (img) {
          ctx.drawImage(img, o.x, o.y, o.width, o.height);
        } else {
          ctx.fillStyle = '#4caf50';
          ctx.fillRect(o.x, o.y, o.width, o.height);
        }
      });
    }

    function drawBonuses() {
      bonuses.forEach(b => {
        let img = null;
        if (b.type === 'beer') {
          img = getAnimatedFrame(beerFrames, bonusAnimTime, 8, null);
        } else {
          img = getAnimatedFrame(rumFrames, bonusAnimTime, 8, null);
        }

        if (img) {
          ctx.drawImage(img, b.x, b.y, b.width, b.height);
        } else {
          ctx.fillStyle = '#ffb300';
          ctx.fillRect(b.x, b.y, b.width, b.height);
        }
      });
    }

    function drawGirls(dt) {
      const img = getAnimatedFrame(girlsFrames, girlsAnimTime, 6, images.girlsStatic);
      if (!img) return;

      let y = GIRLS_Y;
      if (gameState === 'finishing') {
        const t = performance.now() / 300;
        const bounce = Math.sin(t) * 8;
        y += bounce;
      }

      ctx.drawImage(img, GIRLS_X, y, GIRLS_WIDTH, GIRLS_HEIGHT);
    }

    function drawFinalScene() {
      const img = getAnimatedFrame(winFrames, finalAnimTime, 10, images.antonWinStatic);

      if (img) {
        const maxW = WIDTH * 0.6;
        const maxH = HEIGHT * 0.6;
        const scale = Math.min(maxW / img.width, maxH / img.height, 1);
        const drawW = img.width * scale;
        const drawH = img.height * scale;
        const x = (WIDTH - drawW) / 2;
        const y = (HEIGHT - drawH) / 2;
        ctx.drawImage(img, x, y, drawW, drawH);
      } else {
        const w = WIDTH * 0.4;
        const h = HEIGHT * 0.4;
        const x = (WIDTH - w) / 2;
        const y = (HEIGHT - h) / 2;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(x, y, w, h);
        ctx.fillStyle = '#fff';
        ctx.font = '28px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Anton Win!', WIDTH / 2, HEIGHT / 2);
        ctx.textAlign = 'left';
      }
    }

    function drawFlyingHearts() {
      flyingHearts.forEach(h => {
        drawHeartShape(h.x - 13, h.y - 13, 26, 26, '#ff4b6a', '#ff9aa8', false);
      });
    }

    // --- –∞–ø–¥–µ–π—Ç –∏ —Ä–µ–Ω–¥–µ—Ä ---
    function update(dt) {
      if (gameState === 'running') {
        game.speed = 8 + game.obstaclesPassed * 0.15;
        player.runAnimTime += dt;

        obstacleAnimTime += dt;
        bonusAnimTime += dt;
        girlsAnimTime += dt;

        player.vy += player.gravity;
        player.y += player.vy;
        if (player.y >= groundY - player.height) {
          player.y = groundY - player.height;
          player.vy = 0;
          player.isOnGround = true;
        }

        if (player.isSliding) {
          player.slideTimer -= dt;
          if (player.slideTimer <= 0) {
            player.isSliding = false;
          }
        }

        if (player.hitTimer > 0) {
          player.hitTimer -= dt;
          if (player.hitTimer < 0) player.hitTimer = 0;
        }

        game.spawnTimer -= dt;
        if (game.spawnTimer <= 0) {
          spawnObstacle();
          game.spawnTimer = game.spawnInterval;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const o = obstacles[i];
          o.x -= game.speed;
          if (!o.passed && o.x + o.width < player.x) {
            o.passed = true;
            game.obstaclesPassed++;
            game.score += 10;

            if (game.obstaclesPassed >= game.totalObstaclesToWin && gameState === 'running') {
              gameState = 'finishing';
              player.isOnGround = true;
              player.vy = 0;
              player.y = groundY - player.height;

              // –æ—á–∏—â–∞–µ–º –ø–æ–ª–µ –æ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –∏ –±–æ–Ω—É—Å–æ–≤
              obstacles.length = 0;
              bonuses.length = 0;
            }
          }
          if (o.x + o.width < -40) {
            obstacles.splice(i, 1);
          }
        }

        for (let i = bonuses.length - 1; i >= 0; i--) {
          const b = bonuses[i];
          b.x -= game.speed;
          if (b.x + b.width < -40) {
            bonuses.splice(i, 1);
            continue;
          }

          const pb = getPlayerHitbox();
          if (rectsOverlap(pb, b)) {
            bonuses.splice(i, 1);
            if (game.lives < game.maxLives) {
              game.lives++;
              spawnFlyingHeart(b.x + b.width/2, b.y + b.height/2);
            }
          }
        }

        const pb = getPlayerHitbox();
        obstacles.forEach(o => {
          const trimmedHeight = o.height * 0.55;
          const trimmedY = o.y + (o.height - trimmedHeight);
          const trimmedWidth = o.width * 0.7;
          const trimmedX = o.x + (o.width - trimmedWidth) / 2;

          const obstacleHitbox = {
            x: trimmedX,
            y: trimmedY,
            width: trimmedWidth,
            height: trimmedHeight
          };

          if (rectsOverlap(pb, obstacleHitbox) && player.hitTimer <= 0) {
            game.lives--;
            player.hitTimer = player.invincibleTime;
            if (game.lives <= 0) {
              finishGame(false);
            }
          }
        });

        updateFlyingHearts(dt);
      } else if (gameState === 'finishing') {
        player.runAnimTime += dt;
        girlsAnimTime += dt;

        const targetX = GIRLS_X - 60;
        const dir = targetX - player.x;
        const move = Math.sign(dir) * game.speed * 16 * dt;

        if (Math.abs(dir) <= Math.abs(move)) {
          player.x = targetX;
          gameState = 'final_scene';
          finalSceneTimer = 5.0;
          finalAnimTime = 0;
          showSpeech('Oh yeah!', 0.7);
        } else {
          player.x += move;
        }

        updateFlyingHearts(dt);
      } else if (gameState === 'final_scene') {
        finalAnimTime += dt;
        finalSceneTimer -= dt;
        if (finalSceneTimer <= 0 && gameState === 'final_scene') {
          finishGame(true);
        }
      }
    }

    function render(dt) {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawBackground(dt);

      if (gameState === 'final_scene') {
        drawFinalScene();
        return;
      }

      drawHearts();
      drawScore();
      drawObstacles();
      drawBonuses();
      drawGirls(dt);
      drawPlayer(dt);
      drawFlyingHearts();
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      render(dt);

      requestAnimationFrame(loop);
    }

    resetGame();
    showSpeech('Anton is ready!', 1.5);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
